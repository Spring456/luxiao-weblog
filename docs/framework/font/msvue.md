## 常见的Vue面试题

**1、谈谈你对Vue中响应式数据的理解？**

数组和对象类型的值变化的时候，通过defineReactive方法，借助了defineProperty，将所有的属性添加了getter和setter。用户在取值和设置的时候，可以进行一些操作。

缺陷：只能监控最外层的属性，如果是多层的，就要进行全量递归。

get里面会做依赖搜集（dep[watcher, watcher]）

set里面会做数据更新（notify，通知watcher更新）

**2、如何理解Vue中的模板编译原理？**

这个问题的核心是如何将template转换成render函数。

(1)、将template模块转换成ast语法书 - parserHTML

(2)、对静态语法做标记（某些节点不改变）

(3)、重新生成代码 - codeGen,使用with语法包裹字符串

**3、computed和watch的区别是什么？**

computed和watch都基于watcher来实现的。

computed的属性是具备缓存的，依赖的值不发生变化，对其取值时计算属性方法不会重复执行

watch是监控值的变化，当值发生改变的时候，会调用回调函数

**4、Vue.set方法是如何实现的？**

vue给对象和数组本身都增加了dep属性

当给对象新增不存在的属性的时候，就会触发对象依赖的watcher去更新

当修改数组索引的时候，就调用数组本身的splice方法去更新数组

**5、Vue为什么要用虚拟Dom**

虚拟dom就是用js对象来描述真实Dom，是对真实Dom的抽象

由于直接操作Dom性能低，但是js层的操作效率高，可以将Dom操作转化成对象操作。最终通过diff算法比对差异进行更新Dom

虚拟Dom不依赖真实平台环境，可以实现跨平台

**6、Vue的diff算法原理是什么？**

Vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式+双指针方式比较

先比较两个节点是不是相同节点

相同节点比较属性，复用老节点

先比较儿子节点，考虑老节点和新节点儿子的情况

优化比较：头头、尾尾、头尾、尾头

比对查找，进行复用

**7、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？**

响应式数据变化，Vue确实可以在数据变化的时候，响应式系统可以立刻得知。但是如何每个属性都添加watcher的话，性能会非常的差。

粒度过细，会导致更新不精准

所以采用watcher + Diff算法来检测差异。

**8、谈谈Vue的性能优化有哪些？**

数据层级不要过深，合理的设置响应式数据

使用数据时，缓存值的结果，不频繁取值

合理设置key

v-show(频繁切换性能高)和v-if的合理使用

控制组件的粒度 -> Vue采用组件级别更新

采用函数式组件 -> 函数式组价开销低

采用异步组件 -> 借助webpack的分包策略

使用keep-alive来缓存组件

虚拟滚动、时间分片等策略

打包优化

**9、vue中css scoped的原理**

原理就是使用PostCSS转译，PostCSS给每个组件的所有dom添加独一无二的动态属性，然后给css选择器额外添加一个对应的属性选择器来选择该组件中的dom，这样做法使得样式只作用于含有该属性的dom.

**10、vue router底层原理，不同模式下，history路由属性页面会404的原因和解决办法**

原因：只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404

vue路由模式设置为history时再部署到nginx刷新或者路由地址错误的时候会报nginx的404错误，只要在nginx的配置文件中加入这个就可以啦

服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
