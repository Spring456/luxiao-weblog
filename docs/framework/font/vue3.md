## vue3和vue2比较，vue3做了哪些优化？

### 响应式系统升级

vue2:使用Object.defineProperty对数据进行劫持。作者由于性能原因，没有对新增属性或者data中未定义的值，以及无法跟踪数组索引以及通过数组length改变数组做监听。

vue3：使用proxy解决了这些问题

### diff算法的优化

vue2:虚拟dom的比较是全量对比，每个节点不论写死还是动态都会一层一层比较，比较浪费资源

vue3:新增静态标记(patchflag)。与上次虚拟节点比较时，只对比带有patch flag的节点，动态数据所在的节点，可通过flag信息得知当前节点要对比的具体内容。

### hoistStatic 静态提升

vue2：无论元素是否参与更新，每次都会重新创建然后再渲染

vue3：对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用即可。

### cacheHandlers 事件侦听器缓存

vue2:绑定事件每次触发都要重新生成全新的function去更新

vue3：cacheHandlers 是Vue3中提供的事件缓存对象，当 cacheHandlers 开启，会自动生成一个内联函数，同时生成一个静态节点。当事件再次触发时，只需从缓存中调用即可，无需再次更新。

### SSR渲染

vue2：

vue3：当存在大量静态内容时，这些内容会被当作纯字符串推进一个 buffer 里面，即使存在动态的绑定，会通过模版插值潜入进去。这样会比通过虚拟 dmo 来渲染的快上很多。

### 对TS的支持

vue2：不适合使用ts，原因在于vue2的Option API风格。options是个简单对象，而ts是一种类型系统、面向对象的语法。

vue3：量身打造了defineComponent函数，使组件在ts下，更好的利用参数类型推断 。Composition API 代码风格中，比较有代表性的api就是 ref 和 reactive，也很好的支持了类型声明。

### Compostion API: 组合API/注入API

vue2：组件内使用的是Option API风格(data/methods/mounted)来组织的代码，这样会让逻辑分散

vue3：使用setup函数，着力于JS（逻辑）部分，将逻辑相关的代码放在一起，这样更有利于代码的维护

### 组件允许多根节点

vue2：组件里不允许多节点

vue3：允许多节点

### 按需编译，体积比vue更小

在 Vue 3 中，通过将大多数全局 API 和内部帮助程序移至 ES 模块导出来，实现了这一目标。这使现代的打包工具可以静态分析模块依赖性并删除未使用的导出相关的代码。模板编译器还会生成友好的 Tree-shaking 代码，在模板中实际使用了该功能时才导入该功能的帮助程序。

框架的某些部分永远不会 Tree-shaking，因为它们对于任何类型的应用都是必不可少的。我们将这些必不可少的部分的度量标准称为基准尺寸。尽管增加了许多新功能，但 Vue 3 的基准大小压缩后约为 10 KB，还不到 Vue 2 的一半。
