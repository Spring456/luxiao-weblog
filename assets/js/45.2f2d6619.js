(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{491:function(e,t,v){e.exports=v.p+"assets/img/observe.4a216290.jpg"},637:function(e,t,v){"use strict";v.r(t);var r=v(2),_=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"了解vue双向绑定原理-响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#了解vue双向绑定原理-响应式原理"}},[e._v("#")]),e._v(" 了解vue双向绑定原理/响应式原理")]),e._v(" "),t("p",[e._v("先上结论：")]),e._v(" "),t("blockquote",[t("p",[e._v("vue数据双向绑定是通过数据劫持结合发布-订阅者模式的方式来实现的。")])]),e._v(" "),t("p",[e._v("什么是数据劫持？")]),e._v(" "),t("p",[e._v("数据劫持是指在访问或修改对象的某个属性时，先触发一段函数进行额外的操作，再返回结果。")]),e._v(" "),t("p",[e._v("比较典型的就是Vue 2.x 使用的是"),t("code",[e._v("Object.defineProperty()")]),e._v("(Vue 在 3.x 版本之后改用 Proxy 进行实现)。")]),e._v(" "),t("p",[e._v("关于Object.defineProperty()的语法,请参考："),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",target:"_blank",rel:"noopener noreferrer"}},[e._v("Object.defineProperty()"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"什么是发布订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是发布订阅模式"}},[e._v("#")]),e._v(" 什么是发布订阅模式？")]),e._v(" "),t("p",[e._v("发布订阅模式中包含3个模块："),t("code",[e._v("发布者，订阅者，调度中心")]),e._v("。")]),e._v(" "),t("p",[e._v("举个例子来说，当我们喜欢某个公众号的文章时，但我们不知道这个公众号什么时候发布文章，我们就需要去关注它，当有文章推动时，会有消息及时通知我们文章更新了。")]),e._v(" "),t("p",[e._v("这就是典型的发布订阅模式。公众号属于发布者，用户属于订阅者，因为用户有很多，公众号发布文章后是不会直接通知用户的，而是将发布文章的这个事情发布到调度中心(消息中心)，然后调度中心(消息中心)发消息告知用户公众号更新了。")]),e._v(" "),t("p",[e._v("好了，我们知道了vue双向绑定的原理，来看看数据双向绑定的过程。")]),e._v(" "),t("h3",{attrs:{id:"vue双向绑定的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue双向绑定的过程"}},[e._v("#")]),e._v(" vue双向绑定的过程")]),e._v(" "),t("p",[e._v("MVVM模式下，数据变化更新视图，视图变化更新数据。其中视图更新，我们可以通过事件监听的方式来实现，比如input监听change或input事件即可。那数据改变，如何更新视图呢？")]),e._v(" "),t("p",[e._v("数据更新视图，就是通过"),t("code",[e._v("Object.defineProperty()")]),e._v("对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。")]),e._v(" "),t("p",[e._v("结合发布订阅模式和"),t("code",[e._v("Object.defineProperty()")]),e._v("，数据双向绑定的实现过程如下：")]),e._v(" "),t("p",[e._v("1、设置一个监听器(Observer),用来劫持并监听所有属性，如果有变动，就进入消息订阅器(消息中心/调度中心)")]),e._v(" "),t("p",[e._v("2、消息订阅器收集这些订阅者并通知订阅者(Watcher)。订阅者可以接收到属性的变化并执行相应的函数")]),e._v(" "),t("p",[e._v("3、指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数")]),e._v(" "),t("p",[e._v("4、订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图")]),e._v(" "),t("p",[e._v("请参考下图：")]),e._v(" "),t("p",[t("img",{attrs:{src:v(491),alt:"双向绑定原理"}})]),e._v(" "),t("h3",{attrs:{id:"结合源码分析vue的响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结合源码分析vue的响应式原理"}},[e._v("#")]),e._v(" 结合源码分析vue的响应式原理")]),e._v(" "),t("p",[e._v("首先vue主要有3个核心类。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("1、Observer--监听器")])])]),e._v(" "),t("p",[e._v("给对象的属性添加getter和setter，用于"),t("code",[e._v("依赖收集和派发更新")]),e._v("。getter用于依赖收集；setter用于派发更新。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("2、Dep--一个数组")])])]),e._v(" "),t("p",[e._v("用于收集当前响应式对象的依赖关系，每个响应式对象都有一个Dep实例，"),t("code",[e._v("dep.subs=watcher[]")]),e._v(",这个subs是watcher实例数组，当数据发生改变的时，会通过"),t("code",[e._v("dep.notify()")]),e._v("通知各个watcher")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("3、Watcher--观察者对象")])])]),e._v(" "),t("p",[e._v("用于监听各个函数。有各种实例：render watcher,computed watch,user watcher等。")]),e._v(" "),t("p",[e._v("Watcher和Dep的关系：watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。")]),e._v(" "),t("p",[e._v("这里有几个比较重要的概念：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("a、什么是依赖收集？")])])]),e._v(" "),t("p",[e._v("initState:对computed属性初始化时，会触发computed watcher依赖收集；对监听属性初始化的时候，会触发user watcher依赖收集。user watcher指的是用户自己添加的watcher，比如写在watch里面的逻辑")]),e._v(" "),t("p",[e._v("render:会触发render watcher依赖收集")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("b、什么是派发更新")])])]),e._v(" "),t("p",[e._v("主要是通过"),t("code",[e._v("Object.defineProperty")]),e._v("方法对数据进行处理")]),e._v(" "),t("p",[e._v("1、组件中对响应的数据进行修改，触发setter逻辑")]),e._v(" "),t("p",[e._v("2、调用dep.notify()")]),e._v(" "),t("p",[e._v("3、遍历所有subs(wachter实例),调用每一个watcher的update方法")]),e._v(" "),t("h3",{attrs:{id:"结合上图总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结合上图总结"}},[e._v("#")]),e._v(" "),t("code",[e._v("结合上图总结：")])]),e._v(" "),t("p",[e._v("当创建vue实例时，vue会先遍历data里面的属性，利用object.definedProperty为属性添加getter和setter对数据的读取进行劫持。其中getter就是依赖收集；setter就是派发更新。并且在内部追踪依赖,在属性被访问和修改时通知变化。")]),e._v(" "),t("p",[e._v("每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。")])])}),[],!1,null,null,null);t.default=_.exports}}]);