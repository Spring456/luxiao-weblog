(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{646:function(t,e,c){"use strict";c.r(e);var h=c(2),o=Object(h.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"computed-watch-method执行的先后顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-watch-method执行的先后顺序"}},[t._v("#")]),t._v(" computed，watch，method执行的先后顺序")]),t._v(" "),e("p",[t._v("1、computed：计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。")]),t._v(" "),e("p",[t._v("2、methods：methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。")]),t._v(" "),e("p",[t._v("3、watch：是一种更通用的方式来观察和响应 Vue 实例上的数据变动。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。")]),t._v(" "),e("p",[t._v("通俗来讲，")]),t._v(" "),e("p",[t._v("computed是在HTML DOM加载后马上执行的，如赋值；")]),t._v(" "),e("p",[t._v("而methods则必须要有一定的触发条件才能执行，如点击事件；")]),t._v(" "),e("p",[t._v("watch呢？它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。")]),t._v(" "),e("p",[t._v("所以他们的执行顺序为：默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。")]),t._v(" "),e("p",[t._v("下面的例子可以做为说明。")]),t._v(" "),e("p",[t._v("computed 属性 vs watched 属性：Vue 确实提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：watch 属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的想法是使用 computed 属性而不是命令式的 watch 回调。")]),t._v(" "),e("p",[t._v("所以他们的执行顺序为：默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。")])])}),[],!1,null,null,null);e.default=o.exports}}]);