(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{764:function(a,n,s){"use strict";s.r(n);var e=s(2),t=Object(e.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"详解js变量提升和函数提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#详解js变量提升和函数提升"}},[a._v("#")]),a._v(" 详解JS变量提升和函数提升")]),a._v(" "),n("p",[a._v("在开始之前，我们先看一个例子：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("console.log(a)//undefined\nvar a='1'\n")])])]),n("p",[a._v("为什么打印出来的是undefined呢？而不是报错呢？因为undefined表明的是声明未定义(赋值)啊？这是为什么呢？再来一个例子：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("console.log(a)//f a(){}\nvar a=2\nfunction a(){}\n")])])]),n("p",[a._v("在上面的例子中，声明了变量a并且赋值为2，同时声明了函数a，在最上面打印出来的a却是函数a(){},这又是为什么呢？")]),a._v(" "),n("p",[a._v("上面两个例子，原因都体现在js的变量提升/函数声明提升。这和js引擎解析代码有关。")]),a._v(" "),n("h2",{attrs:{id:"js-预解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-预解析"}},[a._v("#")]),a._v(" JS'预解析'")]),a._v(" "),n("p",[a._v("JS引擎在执行代码之前会进行一个'预解析'.具体步骤如下：")]),a._v(" "),n("p",[a._v("1、页面创建全局对象(window对象)")]),a._v(" "),n("p",[a._v("2、加载脚本文件，进行语法分析")]),a._v(" "),n("p",[a._v("3、预编译：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("a、查找变量，查找var关键字，作为window的属性，赋值为undefined\n\nb、查找函数声明，作为window的属性，赋值为函数体，\n\nC、如果变量名称和函数名称相同，会被函数声明覆盖掉。函数声明提升优于变量的声明提升。\n")])])]),n("p",[a._v("4、执行代码阶段")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("a、变量赋值\n\nb、查找到函数声明后，值赋值给函数体\n\nc、如果函数有调用，则执行函数里的代码，执行完毕后，销毁函数声明\n\nd、重复预编译步骤\n")])])]),n("h3",{attrs:{id:"变量提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量提升"}},[a._v("#")]),a._v(" 变量提升")]),a._v(" "),n("p",[a._v("我们了解了JS是如何编译执行代码之后，我们来解析上面的问题.")]),a._v(" "),n("p",[a._v("当我们创建变量时：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a=1\nvar b=2\n")])])]),n("p",[a._v("JS在定义变量时，并不是声明了一个变量就立马复制给变量，而是先将所有的声明完成之后再到定义变量的地方进行赋值。变量的声明的过程就是变量的提升。")]),a._v(" "),n("p",[a._v("上面的代码在执行过程中，其实是这样的：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a;\nvar b;\na=1;\nb=2\n")])])]),n("p",[a._v("再来看一个例子")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a=3\nfunction foo() {\n  var a = 1;\n  console.log(a);\n  console.log(b);\n  var b = 2;\n}\nfoo();\n")])])]),n("p",[a._v("解析：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function foo() {\n  var a;\n  var b;\n  a = 1;\n  console.log(a);//1\n  console.log(b);//undefined\n  b = 2;\n}\nfoo();\n")])])]),n("p",[a._v("变量提升只是在其作用域内，来看下一个例子")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a=1\nconsole.log(a)\nfunction b(){\n    console.log(a)\n    if(!a){\n        var a=2\n        console.log(a)\n    }\n    console.log(a)\n}\nconsole.log(a)\nb()\n")])])]),n("p",[a._v("解析过程为及最后的结果为：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a;\na=1\nconsole.log(a)//1\nfunction b(){\n    var a;\n    console.log(a)//undefined\n    if(!a){//a为undefined，所以为真\n        a=2\n        console.log(a)//2\n    }\n    console.log(a)//2\n}\nconsole.log(a)//1\nb()\n")])])]),n("p",[a._v("上面的例子说明了：变量声明在其作用域内才进行变量声明提升")]),a._v(" "),n("h3",{attrs:{id:"函数声明提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数声明提升"}},[a._v("#")]),a._v(" 函数声明提升")]),a._v(" "),n("p",[a._v("变量的提升分两步：第一步是变量声明的提升；第二步是变量的赋值；")]),a._v(" "),n("p",[a._v("对于函数声明提升，分为这几步：")]),a._v(" "),n("p",[a._v("1、将直接将整个函数整体提升到作用域的最开始位置。")]),a._v(" "),n("p",[a._v("2、变量名称和函数名称相同时，函数名称覆盖变量名称，函数体覆盖变量赋值")]),a._v(" "),n("p",[a._v("3、再解析到函数是否被调用，只有函数被调用的时候才执行函数体内部的代码。")]),a._v(" "),n("p",[a._v("4、函数被调用之后，这个函数声明就会被销毁，有声明，但并未赋值。预解析从头开始。")]),a._v(" "),n("p",[a._v("首先来看个简单的例子：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function foo() {\n  console.log(a);\n  var a = 1;\n  console.log(a);\n  function a() {}\n  console.log(a);\n}\nfoo();\n")])])]),n("p",[a._v("上面的代码在js眼中是这样解析的：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function foo() {\n  var a;\n  function a() {}\n  console.log(a); // a(){}\n  a = 1;\n  console.log(a); // 1\n  console.log(a); // 1\n}\nfoo();\n")])])]),n("p",[a._v("如果碰到了函数调用，则执行函数体里的代码。当函数调用之后，函数被销毁；当碰到同名的函数，后面的函数会覆盖前面的函数")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("console.log(a) \na(); \nvar a = 1;\nfunction a() {    \n    console.log(2)\n};\nconsole.log(a) \na = 3;\na(); \n")])])]),n("p",[a._v("js解析如下")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a;\nfunction a() {    \n    console.log(2)\n};\nconsole.log(a) // 最后的声明为函数声明， 因此a此时为函数体\na(); // 执行 a 函数，输出2.此时变量a的值销毁，a声明但未定义\nvar a;\na = 1; // 1 赋给a\nconsole.log(a) // 1\na = 3; // 3赋给a，不是一个函数，故下方执行throw error\nconsole.log(a)//3\na(); // throw error\n")])])]),n("p",[a._v("推荐文章：\n"),n("a",{attrs:{href:"https://towind.fun/2021/05/10/js-hoisting/",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavsScript 变量提升和函数提升"),n("OutboundLink")],1),a._v(" "),n("a",{attrs:{href:"https://fangyinghang.com/let-in-js/",target:"_blank",rel:"noopener noreferrer"}},[a._v("我用了两个月的时间才理解 let"),n("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=t.exports}}]);