(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{490:function(t,e,a){t.exports=a.p+"assets/img/vue_tp1.0d95072c.png"},636:function(t,e,a){"use strict";a.r(e);var n=a(2),p=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"怎么理解vue的单向数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么理解vue的单向数据流"}},[t._v("#")]),t._v(" 怎么理解Vue的单向数据流")]),t._v(" "),e("p",[t._v("vue官网上对单向数据流有如下定义：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(490),alt:"单向数据流"}})]),t._v(" "),e("p",[t._v("总结就是：")]),t._v(" "),e("p",[t._v("1、vue组件间传递数据是单向的，即父组件将props传递给子组件，子组件接收数据但不能直接修改传递过来的数据。父组件的值更新时，会下行流动到子组件中，子组件的props的值也会发生更新")]),t._v(" "),e("p",[t._v("2、子组件不能修改父组件传递过来的数据，否则会报错")]),t._v(" "),e("p",[e("strong",[t._v("为什么子组件不能修改父组件的值呢？")])]),t._v(" "),e("p",[t._v("因为父组件的值可能是不断变化的，更新时，子组件的props的值也会发生变化。如果子组件可以修改父组件传过来的值，比如子组件接收了num=1,当子组件将其改为2的时候，父组件又传递过来了3，会影响子组件的使用。因此这vue中，组件的传值是单向的。")]),t._v(" "),e("p",[t._v("这样做的好处：")]),t._v(" "),e("p",[t._v("1、多个组件可以互相解耦")]),t._v(" "),e("p",[t._v("2、多个子组件依赖父组件的数据时，子组件组件变化，不影响其他子组件的数据。所以 Vue 不推荐子组件修改父组件的数据，直接修改 prop 会抛出警告。")]),t._v(" "),e("p",[e("strong",[t._v("希望子组件改变父组件的值，官网提供了两个方法")])]),t._v(" "),e("blockquote",[e("p",[t._v("1、在子组件 data 中创建一个变量获取 props 中的值，再改变这个 data 中的值。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("props: ['number'],\ndata() {\n  return {\n    counter: this.number\n  }\n}\n")])])]),e("p",[t._v("这个方法相当于在子组件里创建了prop的副本，之后操作的都是子组件的数据，不会影响到父组件。")]),t._v(" "),e("blockquote",[e("p",[t._v("2、子组件定义一个计算属性，处理 prop 的值并返回，通过$emit的方式传递给父组件")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("props: ['size'],\ncomputed: {\n  normalizedSize: function () {\n    return this.size.trim().toLowerCase()\n  }\n}\n")])])]),e("p",[t._v("这个方法trim() 会返回一个处理完成后的新字符串，同样不会影响到父组件数据（原字符串）。之后如果父组件确实要用到这个处理后的值，就通过 $emit 的方式传给父组件。")]),t._v(" "),e("p",[t._v("如果改变props的值，还需要注意一个问题：")]),t._v(" "),e("blockquote",[e("p",[t._v("注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。")])]),t._v(" "),e("p",[t._v("父组件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<template>\n  <div class=\"hello\">\n    <h2>父组件数据：{{ parentData }}</h2>\n    <childVue :childObj=\"parentData\"></childVue>\n  </div>\n</template>\n<script>\nimport childVue from './child.vue'\nexport default {\n  name: 'HelloWorld',\n  components: {childVue},\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App',\n      parentData: { num: 20 }\n    }\n  }\n}\n")])])]),e("p",[t._v("子组件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<template>\n  <div>\n    <h3>子组件数据：{{ childData }}</h3>\n    <input type=\"text\" v-model=\"childData.num\" />\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['childObj'],\n  name: '',\n  data () {\n    return {\n      childData: this.childObj,\n      //childData: Object.assign({}, this.childObj) //不会影响父组件数据\n    }\n  }\n}\n")])])]),e("p",[t._v("当我们改变子组件的值时，父组件的值也相应的改变了。因为数组或对象是引用形式，childData最后还是指向了父组件的数据。改变子组件依然会影响到父组件。")]),t._v(" "),e("p",[t._v("如果希望子组件改变不影响父组件，我们需要在子组件里对数据进行拷贝(浅拷贝或深拷贝以数据结构而定)")])])}),[],!1,null,null,null);e.default=p.exports}}]);