(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{721:function(t,n,a){"use strict";a.r(n);var s=a(2),e=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"js中小数运算和大整数精度丢失"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js中小数运算和大整数精度丢失"}},[t._v("#")]),t._v(" JS中小数运算和大整数精度丢失")]),t._v(" "),n("h3",{attrs:{id:"奇怪的问题-浮点数运算或大数的精度问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#奇怪的问题-浮点数运算或大数的精度问题"}},[t._v("#")]),t._v(" 奇怪的问题--浮点数运算或大数的精度问题")]),t._v(" "),n("p",[t._v("在JS中，对小数或较大的数进行运行操作会出现不可预计的问题，比如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("0.1+0.2=0.30000000000000004\n\n0.1+0.7=0.7999999999999999\n\n1.2-0.1=1.0999999999999999\n\n0.5-0.4=0.09999999999999998\n\n19.19 * 100=1919.0000000000002\n\n0.3/0.2=1.4999999999999998\n\nconsole.log(10000000000000011) //10000000000000012\nconsole.log(0.1000000000000001) \n// 0.1000000000000001 (中间14个0，会打印出本身)\nconsole.log(0.10000000000000001) \n// 0.1 (中间15个0，js会认为两个值足够近似，所以输出0.1)\n")])])]),n("p",[t._v("刚接触到这个问题的时候，着实令人头大，这是为什么？为什么会发生这样的事情！以后在运算的时候应该怎么办？")]),t._v(" "),n("p",[t._v("原因：")]),t._v(" "),n("p",[n("code",[t._v("1、进制转换。")]),t._v("在计算机中，数字无论是整数还是浮点数都是以多位二进制的方式进行存储的。在呈现结果时才转换成十进制。0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。")]),t._v(" "),n("p",[n("code",[t._v("2、对阶运算。")]),t._v("由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。")]),t._v(" "),n("p",[t._v("还是上面的例子：0.1+0.2，先分别将0.1和0.2转换为二进制，然后再进行相加，相加得到的结果转为十进制。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 0.1 转化为二进制\n0.0 0011 0011 0011 0011...(0011循环）\n\n// 0.2 转化为二进制\n0.0011 0011 0011 0011 0011...(0011循环）\n")])])]),n("p",[t._v("由于0.1这样的数值用二进制是无法整除的，最后算下来会是 0.000110011…由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。在JS中如果出现这种无法整除的小数就会取一个近似值，在js中如果这个近似值足够近似，那么js就会认为他就是那个值。")]),t._v(" "),n("p",[t._v("还是上面的例子中，由于0.1转换成二进制时是无限循环的，所以在计算机中0.1只能存储成一个近似值。")]),t._v(" "),n("p",[t._v("在js中，除了那些能表示成 x/2^n 的数可以被精确表示以外，其余小数都是以近似值得方式存在的。")]),t._v(" "),n("p",[t._v("在0.1 + 0.2这个式子中，0.1和0.2都是近似表示的，在他们相加的时候，两个近似值进行了计算，导致最后得到的值是0.30000000000000004，此时对于JS来说，其不够近似于0.3，于是就出现了0.1 + 0.2 != 0.3 这个现象。当然，也并非所有的近似值相加都得不到正确的结果。")]),t._v(" "),n("p",[t._v("对于IEEE 754和二进制运行可以参考：https://juejin.cn/post/6981094321759977479")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.cn/post/7041546152994406430",target:"_blank",rel:"noopener noreferrer"}},[t._v("十进制转二进制"),n("OutboundLink")],1)]),t._v(" "),n("h3",{attrs:{id:"如何解决"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何解决"}},[t._v("#")]),t._v(" 如何解决")]),t._v(" "),n("p",[n("strong",[t._v("1、浮点数变成整数再计算")])]),t._v(" "),n("p",[t._v("将浮点数变成整数再计算，整数是可以精确表示的")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//0.1+0.2\n\nconsole.log((0.1*10+0.2*10)/10)//0.3\n")])])]),n("p",[t._v("但这种方法（乘以10的N次幂，再除以10的n次幂）并不是万能的，就比如上面19.19*10并不等与1919一样。所以这种方法并不保险。")]),t._v(" "),n("p",[n("strong",[t._v("2、使用number对象的toFixed方法")])]),t._v(" "),n("p",[t._v("toFixed方法可以指定运算结果的小数点后的指定位数的数字，使保留一位小数就是toFixed(1)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//let x=(0.1+0.2).toFixed(1)\n//因为使用toFixed方法将number类型转换成了字符串类型\n//，所以使用parseFloat将字符串转回number类型\nlet x=parseFloat((0.1+0.2).toFixed(1));\nconsole.log(x===0.3);\n")])])]),n("p",[t._v("使用toFixed()方法可以把Number四舍五入为指定小数位数的数字。但这种方法也并不是万无一失的。比如下面的例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("1.35.toFixed(1) // 1.4 正确\n1.335.toFixed(2) // 1.33  错误\n1.3335.toFixed(3) // 1.333 错误\n1.33335.toFixed(4) // 1.3334 正确\n1.333335.toFixed(5)  // 1.33333 错误\n1.3333335.toFixed(6) // 1.333333 错误\n")])])]),n("p",[t._v("可以看到使用toFixed()方法，也并不是最好的。")]),t._v(" "),n("p",[n("strong",[t._v("3、将浮点数toString后indexOf('.')")])]),t._v(" "),n("p",[t._v("我们可以将浮点数toString后indexOf('.')，记录一下小数位的长度，然后将小数点抹掉")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" /*** method **\n *  add / subtract / multiply /divide\n * floatObj.add(0.1, 0.2) >> 0.3\n * floatObj.multiply(19.9, 100) >> 1990\n *\n */\nvar floatObj = function() {\n\n    /*\n     * 判断obj是否为一个整数\n     */\n    function isInteger(obj) {\n        return Math.floor(obj) === obj\n    }\n\n    /*\n     * 将一个浮点数转成整数，返回整数和倍数。如 3.14 >> 314，倍数是 100\n     * @param floatNum {number} 小数\n     * @return {object}\n     *   {times:100, num: 314}\n     */\n    function toInteger(floatNum) {\n        var ret = {times: 1, num: 0}\n        if (isInteger(floatNum)) {\n            ret.num = floatNum\n            return ret\n        }\n        var strfi  = floatNum + ''\n        var dotPos = strfi.indexOf('.')\n        var len    = strfi.substr(dotPos+1).length\n        var times  = Math.pow(10, len)\n        var intNum = Number(floatNum.toString().replace('.',''))\n        ret.times  = times\n        ret.num    = intNum\n        return ret\n    }\n\n    /*\n     * 核心方法，实现加减乘除运算，确保不丢失精度\n     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）\n     *\n     * @param a {number} 运算数1\n     * @param b {number} 运算数2\n     * @param digits {number} 精度，保留的小数点数，比如 2, 即保留为两位小数\n     * @param op {string} 运算类型，有加减乘除（add/subtract/multiply/divide）\n     *\n     */\n    function operation(a, b, digits, op) {\n        var o1 = toInteger(a)\n        var o2 = toInteger(b)\n        var n1 = o1.num\n        var n2 = o2.num\n        var t1 = o1.times\n        var t2 = o2.times\n        var max = t1 > t2 ? t1 : t2\n        var result = null\n        switch (op) {\n            case 'add':\n                if (t1 === t2) { // 两个小数位数相同\n                    result = n1 + n2\n                } else if (t1 > t2) { // o1 小数位 大于 o2\n                    result = n1 + n2 * (t1 / t2)\n                } else { // o1 小数位 小于 o2\n                    result = n1 * (t2 / t1) + n2\n                }\n                return result / max\n            case 'subtract':\n                if (t1 === t2) {\n                    result = n1 - n2\n                } else if (t1 > t2) {\n                    result = n1 - n2 * (t1 / t2)\n                } else {\n                    result = n1 * (t2 / t1) - n2\n                }\n                return result / max\n            case 'multiply':\n                result = (n1 * n2) / (t1 * t2)\n                return result\n            case 'divide':\n                result = (n1 / n2) * (t2 / t1)\n                return result\n        }\n    }\n\n    // 加减乘除的四个接口\n    function add(a, b, digits) {\n        return operation(a, b, digits, 'add')\n    }\n    function subtract(a, b, digits) {\n        return operation(a, b, digits, 'subtract')\n    }\n    function multiply(a, b, digits) {\n        return operation(a, b, digits, 'multiply')\n    }\n    function divide(a, b, digits) {\n        return operation(a, b, digits, 'divide')\n    }\n\n    // exports\n    return {\n        add: add,\n        subtract: subtract,\n        multiply: multiply,\n        divide: divide\n    }\n}();\n")])])]),n("p",[t._v("此方法来自：https://juejin.cn/post/6844903572979597319")]),t._v(" "),n("p",[n("strong",[t._v("4、使用第三方库")])]),t._v(" "),n("p",[t._v("目前解决这一问题的第三方库有：bignumber")]),t._v(" "),n("p",[t._v("地址："),n("a",{attrs:{href:"https://github.com/MikeMcl/bignumber.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("bignumber"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("strong",[t._v("5、使用 Number.EPSILON 误差范围。")])]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEqual")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Math"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("abs")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" b"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" Number"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EPSILON")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEqual")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);