(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{549:function(e,a,s){e.exports=s.p+"assets/img/webpack01.ef991a91.png"},770:function(e,a,s){"use strict";s.r(a);var n=s(2),t=Object(n.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("webpack中的属性，方法更详细参考webpack中文网：https://www.webpackjs.com/concepts/")]),e._v(" "),a("h3",{attrs:{id:"webpack指定打包配置文件命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack指定打包配置文件命令"}},[e._v("#")]),e._v(" webpack指定打包配置文件命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("webpack --config webpack.dev.config.js\n")])])]),a("h3",{attrs:{id:"配合npm脚本使用命令行的参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配合npm脚本使用命令行的参数"}},[e._v("#")]),e._v(" 配合npm脚本使用命令行的参数")]),e._v(" "),a("p",[e._v("/package.json\n"),a("img",{attrs:{src:s(549),alt:"webpack01"}}),e._v("\n然后在命令行运行 npm run webpack")]),e._v(" "),a("h3",{attrs:{id:"webpack核心参数介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack核心参数介绍"}},[e._v("#")]),e._v(" webpack核心参数介绍")]),e._v(" "),a("p",[a("strong",[e._v("1、entry打包入口文件")])]),e._v(" "),a("p",[e._v("为了应付各种需求，官方给出三种方式来匹配不同需求。")]),e._v(" "),a("p",[e._v("第一种: 输入简单string指定一个简单入口文件。所有依赖都在这个一个入口文件指定。")]),e._v(" "),a("p",[e._v("第二种：是一个数组 ，webpack为了解决两个平行互相依赖的文件，却想打包到一起。")]),e._v(" "),a("p",[e._v("第三种：是一个对象分key和value。多页面应用程序会运用这个场景。")]),e._v(" "),a("p",[a("strong",[e._v("2、output 打包出口")])]),e._v(" "),a("p",[e._v("在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：")]),e._v(" "),a("p",[e._v("1、filename 用于输出文件的文件名。")]),e._v(" "),a("p",[e._v("2、目标输出目录 path 的绝对路径。")]),e._v(" "),a("p",[a("strong",[e._v("3、mode模式")])]),e._v(" "),a("p",[e._v("有两种，development和production。如果设置为production就是默认压缩")]),e._v(" "),a("p",[a("strong",[e._v("4、loader")])]),e._v(" "),a("p",[e._v("对模块的源代码进行转换。通过指定Presets来告诉babel loader转换某一些特性，如果转换所有特性可以指定latest（es2015,2016,2017）怎么指定插件呢？给loader指定一个参数Query parameters")]),e._v(" "),a("p",[e._v("1、require（'url-loader？'）//？后面跟参数")]),e._v(" "),a("p",[e._v("2、配置文件中")]),e._v(" "),a("p",[a("code",[e._v("loaders: [ { test: /\\.js$/, loader:'babel', query:{ presets:['lastest'] //指定loader } } ]")])]),e._v(" "),a("p",[e._v("3、还可以在项目根目录建 .babelrc 配置文件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('babel:{\n    "presets":["es2015"]\n}\n')])])]),a("p",[e._v("4、还可以在package.json文件指定")]),e._v(" "),a("p",[e._v("在配置文件中，module.loaders定义的参数解析")]),e._v(" "),a("p",[e._v("● test——js正则匹配 条件")]),e._v(" "),a("p",[e._v("● exclude——loader排除范围，比如某一个目录下不让它处理")]),e._v(" "),a("p",[e._v("● include——loader处理的范围")]),e._v(" "),a("p",[e._v("● loader——单个loader使用字符串形式")]),e._v(" "),a("p",[e._v("● loaders——把一长串的loader通过一个数组表示")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n    test: /\\.js$/,//正则匹配js文件\n    loader: 'babel-loader',//loader，处理js的loader\n    include: './src/',//指定处理的文件夹\n    exclude:'./node_modules',//指定不处理的文件\n    query:{\n        presets:['latest']//指定babel loader转换某一些特性\n    }\n},\n")])])]),a("p",[e._v("还可以使用path来指定处理或不处理的文件。")]),e._v(" "),a("p",[e._v("path是Node的一个模块，用来表示路径相关操作，path对象上有一个方法resolv（解析），dirname是运行环境下的变量，也就是在当前运行环境的路径，后面是相对路径。")]),e._v(" "),a("p",[e._v("（dirname）当前的目录，再加个一个相对路径（api/src），解析完后得到一个绝对路径")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n    test: /\\.js$/,//正则匹配js文件\n    loader: 'babel-loader',//loader，处理js的loader\n    include: path.resolve(__dirname,'src'),//__dirname运行环境下的变量，也就是当前运行环境的路径\n    exclude:path.resolve(__dirname,'node_modules'),//指定不处理的文件\n    query:{\n        presets:['latest']//指定babel loader转换某一些特性\n    }\n},\n")])])]),a("p",[e._v("其他常用的loader有，css-loader、style-loader、html-loader、url-loader等")]),e._v(" "),a("p",[a("strong",[e._v("5、plugins")])]),e._v(" "),a("p",[e._v("由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。")]),e._v(" "),a("p",[e._v("插件目的在于解决 loader 无法实现的其他事。")]),e._v(" "),a("p",[e._v("插件的使用：\n由于插件可以接受参数/选项，因此您必须将new实例传递给pluginswebpack 配置中的属性。")]),e._v(" "),a("p",[e._v("webpack官网提供了若干插件：https://webpack.js.org/plugins/")]),e._v(" "),a("p",[a("strong",[e._v("6、module")])]),e._v(" "),a("p",[e._v("webapck中一切皆模块，webapck会从entry开始递归找到所有的依赖。在module.rules里进行loader的配置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module: {\n    rules: [{        \n        test: /\\.js$/,        \n        loader: 'babel-loader', // js处理        \n        include: [ // Rule.include 是 Rule.resource.include 的简写。如果你提供了 Rule.include 选项，就不能再提供 Rule.resource          \n            resolve('src'),          \n            resolve('test'),          \n            resolve('node_modules/webpack-dev-server/client')        \n        ]      \n    },\n      ...    \n    ]\n}\n")])])]),a("p",[a("strong",[e._v("7、devtool")])]),e._v(" "),a("p",[e._v("用哪一种sourceMap来处理")]),e._v(" "),a("p",[e._v("sourceMap的概念，简单理解，就是我们写的代码，在经过构建工具的处理后，如果在调试的时候出现什么错误，由于代码已经进行过了处理，若果不在处理前就标记好代码的各种信息，处理后无法定位问题，而sourceMap就是做标记的工作。比如说标记代码的行信息，列信息等等。用不同的模式下的souceMap，得到的代码信息不太一样")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("devtool: config.build.productionSourceMap ? config.build.devtool : false,\n")])])]),a("p",[a("strong",[e._v("8、resolve")])]),e._v(" "),a("p",[e._v("模块解析的相关配置。比如文件查找的优先级等")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("resolve: {    \n    // 模块解析相关的配置    \n    extensions: ['.js', '.vue', '.json'], // 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js    \n    alias: { // 如果我们有某个模块及其常用，经常编写相对路径很麻烦，就可以在此处配置某个模块的别名      \n        '@': resolve('src')    \n    }  \n}\n")])])]),a("p",[a("strong",[e._v("9、performance")])]),e._v(" "),a("p",[e._v("性能配置，里面的配置项能控制webpack如何通知资源和入口超过指定文件限制。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("performance: {\n    hints: 'warning', // 警告 室还有一个值是error\n    maxAssetSize: 30000000, // 整数类型（以字节为单位） 资源(asset)是从 webpack 生成的任何文件。此选项根据单个资源体积，控制 webpack 何时生成性能提示。默认250000    maxEntrypointSize: 50000000 // 整数类型（以字节为单位） 默认250000 此选项根据入口起点的最大体积，控制 webpack 何时生成性能提示\n}\n")])])]),a("p",[a("strong",[e._v("10、optimization")])]),e._v(" "),a("p",[e._v("优化打包的配置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("optimization: { // 优化    \n    splitChunks: { // 动态导入模块，webpack4+的全新通用分块策略配置    \n        chunks: 'all',    \n        cacheGroups: {      \n            libs: {        \n                name: 'chunk-libs',        \n                test: /[\\\\/]node_modules[\\\\/]/,        \n                priority: 10,        \n                chunks: 'initial' // 只打包初始时依赖的第三方      \n            },      \n            elementUI: {          \n                name: 'chunk-elementUI', // 单独将 elementUI 拆包          \n                priority: 20, // 权重要大于 libs 和 app 不然会被打包进 libs 或者 app          \n                test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/        \n            }      \n        }    \n    },    \n    runtimeChunk: 'single', // 值 \"single\" 会创建一个在所有生成 chunk 之间共享的运行时文件    \n    minimizer: [ //允许你通过提供一个或多个定制过的 TerserPlugin 实例，覆盖默认压缩工具(minimizer)。      \n        new UglifyJsPlugin({        \n            uglifyOptions: {          \n                mangle: { // 混淆            \n                    safari10: true          \n                }        \n            },        \n            sourceMap: config.build.productionSourceMap, // 编译后代码对源码的映射，用于网页调试        \n            cache: true,        \n            parallel: true      \n        }),      \n        // 压缩提取的CSS。使用此插件减少来自不同组件的可能重复的CSS      \n        new OptimizeCSSAssetsPlugin()    \n    ]  \n}\n")])])]),a("h3",{attrs:{id:"plugins和loaders的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#plugins和loaders的区别"}},[e._v("#")]),e._v(" plugins和loaders的区别")]),e._v(" "),a("p",[e._v("loader 用于对模块的源代码进行转换。")]),e._v(" "),a("p",[e._v('loader 可以使你在 import 或"加载"模块时预处理文件。')]),e._v(" "),a("p",[e._v("因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。")]),e._v(" "),a("p",[e._v("插件是 webpack 的支柱功能。")]),e._v(" "),a("p",[e._v("webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！")]),e._v(" "),a("p",[e._v("插件目的在于解决 loader 无法实现的其他事")]),e._v(" "),a("p",[a("strong",[e._v("plugin是在loader之后执行的，当loader处理完模块代码，plugin继续处理loader未能做完的事情")])])])}),[],!1,null,null,null);a.default=t.exports}}]);