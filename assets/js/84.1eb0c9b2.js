(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{577:function(v,_,t){"use strict";t.r(_);var e=t(2),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"指标采集-首屏时间指标采集具体办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指标采集-首屏时间指标采集具体办法"}},[v._v("#")]),v._v(" 指标采集---首屏时间指标采集具体办法")]),v._v(" "),_("h3",{attrs:{id:"手动采集办法及优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#手动采集办法及优缺点"}},[v._v("#")]),v._v(" 手动采集办法及优缺点")]),v._v(" "),_("p",[v._v("所谓手动采集，一般是通过埋点方式")]),v._v(" "),_("p",[v._v("埋点方式，有页面，区域统计时间的，有按钮点击的触发事件等统计。")]),v._v(" "),_("p",[v._v("如果是电商类商品详情页，首屏包括头图，购买，商品信息，下单按钮等，就在这些内容加载完毕的位置打上首屏结束的点。")]),v._v(" "),_("p",[v._v("如果是电商列表页，瀑布流型的页面，需要根据各个机型下的首屏位置，估算一个平均的首屏位置，然后打上点。")]),v._v(" "),_("p",[v._v("如果是直播型的页面，页面核心是一个直播框，就需要在直播框的结束位置，打上点。")]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("p",[v._v("兼容性强，可以随情况变动；其次是去中心化，各个业务负责自己的打点代码，有问题时业务同学去排查即可。")]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("p",[v._v("手动采集会和业务代码严重耦合，它的覆盖率不足，业务一旦忙起来，性能优化方案就会延迟排后。而且依赖个人，所有不同的人在采集过程中可能会出现遗漏，不准确等问题。")]),v._v(" "),_("h3",{attrs:{id:"自动化采集优化及方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自动化采集优化及方法"}},[v._v("#")]),v._v(" 自动化采集优化及方法")]),v._v(" "),_("blockquote",[_("p",[v._v("自动化采集：即引入一段通用的代码来做首屏时间自动化采集引入过程中，除了必要的配置不需要做其他事情。")])]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("p",[v._v("独立性更强，接入过程更自动化，由一个公共团队来开发，试点后，推广到各个业务团队")]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("p",[v._v("有些个性化需要无法满足，毕竟在工作中，总会有一些特殊业务场景。")]),v._v(" "),_("ul",[_("li",[v._v("自动化采集具体怎么采集呢？都有哪些方法")])]),v._v(" "),_("p",[v._v("首屏指标自动化采集，需要考虑的是服务端模板业务，还是单页面(SPA)应用开发业务，业务场景不同，对应的采集方法不同。")]),v._v(" "),_("h3",{attrs:{id:"服务端模板业务下的采集办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务端模板业务下的采集办法"}},[v._v("#")]),v._v(" 服务端模板业务下的采集办法")]),v._v(" "),_("p",[v._v("服务端渲染情况下，后端比较重，前端偏配合，处于效率方面的考虑，前后端并没有解耦。")]),v._v(" "),_("p",[v._v("服务端加载流程是怎样的呢？")]),v._v(" "),_("p",[v._v("http请求---HTML文档加载解析完成(这个时间就是首屏加载时间)--加载样式和脚本文件--完成页面渲染。")]),v._v(" "),_("p",[v._v("这个首屏时间点，可以用浏览器提供的DOMContentLoaded接口来实现。在network里，可以看到有DOMContentLoaded这个选项，表示HTML元素加载解析需要的时间。这个时间点就是首屏时间。")]),v._v(" "),_("p",[v._v("DOMContentLoaded时间具体的采集思路是怎样的呢？")]),v._v(" "),_("p",[v._v("当页面中的HTML元素被加载和解析完成，DOMContentLoaded事件触发。")]),v._v(" "),_("p",[v._v("简言之：首屏时间=DOMContentLoaded 时间=domContentLoadedEventEnd-fetchStart")]),v._v(" "),_("p",[v._v("这个方法可以应用在单页面下吗？不可以！")]),v._v(" "),_("h3",{attrs:{id:"单页面应用业务下的采集办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单页面应用业务下的采集办法"}},[v._v("#")]),v._v(" 单页面应用业务下的采集办法")]),v._v(" "),_("p",[v._v("SPA页面下，使用performance API接口采集时间会和实际时间有偏差，这是为什么呢？")]),v._v(" "),_("p",[v._v("这是因为：SPA页面加载时，用户请求一个页面，页面会先加载index..html，等待此页面加载完之后，就会触发DOMContentLoaded和load。这个时候页面展示的是空白页，还不是真正的首屏。")]),v._v(" "),_("p",[v._v("接下来，页面会加载相关脚本资源并通过axios异步请求数据，使用数据渲染页面主题部分，这个时候首屏才渲染完成。")]),v._v(" "),_("p",[v._v("由于这个加载过程，SPA的流行让performance接口失去了原来的意义，这种情况下，如何采集首屏指标呢？")]),v._v(" "),_("p",[_("code",[v._v("可以使用MutationObserver采集首屏时间")])]),v._v(" "),_("p",[v._v("在单页面中，如果能在首屏渲染过程中，把各个资源的加载时间记录到日志中，后续在通过分析，确定某一个资源加载完的时间，就是首屏时间。")]),v._v(" "),_("p",[v._v("使用MutationObserver恰好可以做到这点。")]),v._v(" "),_("p",[v._v("MutationObserver的定义：")]),v._v(" "),_("blockquote",[_("p",[v._v("MutationObserver 接口提供了监视对DOM树所做更改的能力，它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。")])]),v._v(" "),_("p",[v._v("简单来说，就是使用MutationObserver监听DOM元素的变化，当HTML元素变化最为剧烈的时候，就是首屏时间。")]),v._v(" "),_("h3",{attrs:{id:"使用mutationobserver"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用mutationobserver"}},[v._v("#")]),v._v(" 使用MutationObserver")]),v._v(" "),_("p",[v._v("在用户进入页面时，我们可以使用MutationObserver监控DOM元素，当DOM元素发生变化时，程序会标记变化的元素，记录时间点和分属，存储到数组中。")]),v._v(" "),_("p",[v._v("首屏指标采集到某些条件时，首屏渲染已经结束，我们需要考虑首屏采集终止的条件。(比如记录几次之后，时间不在变化)")]),v._v(" "),_("p",[v._v("接下来，递归遍历DOM元素及其子元素，根据子元素所在层数设定元素权重。")]),v._v(" "),_("p",[v._v("比如第一层元素权重为1，当它被渲染时得1分，每增加一层权重增加0.5，比如第五层元素权重是3.5，渲染时给出对应的分数。")]),v._v(" "),_("p",[v._v("为什么需要权重呢？")]),v._v(" "),_("p",[v._v("因为页面中每个DOM元素对于首屏的意义是不同的，越往内层越接近真实的首屏内容，如图片或文字，越往外层越接近body等框架层。")]),v._v(" "),_("p",[v._v("根据前面的得分，计算元素的分数变化率，获取变化率最大点对应的分数，然后找到该分数对应的时间，即为首屏时间。")]),v._v(" "),_("p",[v._v("代码部分---见视频")]),v._v(" "),_("p",[v._v("如果页面里包含图片，使用上面的首屏指标采集方案，结果准确吗？")]),v._v(" "),_("p",[v._v("不准确，上述计算逻辑主要是针对DOM元素来做的，图片加载过程是异步，图片容器(图片的DOM元素)和内容的加载是分开的，当容器加载出来时，内容还没出来，一定要确保内容加载出来，才算首屏。")]),v._v(" "),_("p",[v._v("主要逻辑：遍历HTML中的img标签，以及css中引入的图片；然后获取加载时间最大的加载时间。获取图片的路径，")]),v._v(" "),_("p",[v._v("这种性能采集方案靠谱吗？采集过程中会不会有什么坑？")]),v._v(" "),_("p",[v._v("目前来说，这是市面上最好的首屏指标采集方案，它兼容了单页面应用和服务端模板的页面。")]),v._v(" "),_("p",[v._v("采集过程中的坑？")]),v._v(" "),_("p",[v._v("实践过程中确实有不少坑。比如单页面采集过程中，用户恰好操作跳转到其他页面，采集还是继续，但并不是首页了。")])])}),[],!1,null,null,null);_.default=a.exports}}]);